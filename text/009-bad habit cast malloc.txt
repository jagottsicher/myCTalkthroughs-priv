Casting malloc() in C? What is wrong with you?

Pic: Angry Karen, beide Hände erhoben!


















Whenever it comes to use malloc in programming with C, I typecast the malloc() function. This is something I do for quite a while, but never questioned it — until now. I learned that doing so is considered “bad programming practice” by some in the C community and for me a reason to talk about it. Welcome to mCTalkthroughs.

The malloc() function allocates a chunk of memory. The function returns the memory chunk’s address as a type void pointer.

Somewhere along the line, I started typecasting the malloc() function to match the data type of its pointer assignment. So if yadayada is a char pointer, I’d do this:

yadayada = (char *) malloc( 1024 );

This statement allocates a 1024 byte buffer and assigns its address to char pointer yadayada. The (char *) typecast transforms the void pointer into a char pointer for the assignment. Nevertheless, this typecast is unnecessary in the C language.

Probably I read that typecasting the return value of malloc() was strongly suggested. I forgot the specifics, maybe I started typecasting malloc() out of habit. Then I learned that typecasting malloc() is “bad programming practice,” though even this opinion is debated.

First, in the C++ language, typecasting malloc() is mandatory. Due to the crossover of C and C++ material, this could be the reason why I started typecasting malloc(): I read some C code somewhere written by a C++ programmer who just typecasts malloc() for reasons in one language that aren’t required in the other.

Second, the thing that offends some C programmers the most is that by typecasting malloc() you run the risk of improperly identifying the function. In this sense, typecasting works like a mask: When any function is typecast, the compiler may not bother looking up its definition by checking a prototype. I’m unsure of the specifics, but even on this point I see a lot of back-and-forth between C experts.

In the following code, I typecast malloc() without including the stdlib.h header file, which is where the function’s prototype exists:

#include <stdio.h>

int main()
{
    int *p;

    p = (int *)malloc( 1024 );
    if( p==NULL )
        printf("malloc() failed\n");
    else
        printf("malloc() succeeded\n");

    return(0);
}

The program doesn’t build when using clang or gcc: Error messages are output, specifically stating that malloc() is a library function and it requires the stdlib.h header file. Good for these compilers!

With the MinGW compiler, however, the program builds. Warnings are generated, just like with clang and gcc: The malloc() function requires the stdlib.h header file — but the program builds anyway. And it runs. This result is why some programmers caution against typecasting the malloc() function.

Though it isn’t what I consider an unforgivable sin and breaking the eleven's commandment: You shall not typecast malloc(). Yet, I'll try to avaoid it but I also feel it’s an overreaction to say that typecasting malloc() is “bad” programming practice. Given the errors and warnings generated by modern compilers, I’d say typecasting malloc() isn’t bad, just unnecessary and easily avoidable.











